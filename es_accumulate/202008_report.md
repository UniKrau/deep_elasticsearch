# 1、【常见问题】spark调用bulkprocessor批量入库es，存在少量丢数

spark调用bulkprocessor批量入库es，存在少量丢数 

elasticsearch使用spark调用bulkprocessor批量入库es，2亿数据量丢数几百条不知道怎么定位丢数，index字段数据类型已定制成全keyword类型，似乎不是因为类型导致丢数，数据源是标准交易数据，脏数据的概率比较低，请问大家有思路定位分析一下丢数原因


探讨：

目前有想过两个比较笨重的方式

1.入库少量数据，重现丢数场景，逐条打印，对比数据。这个量级起码也要几十万，很笨重

2.在数据源进入spark之前，就增加一个自增字段，并以此字段为自定义ID（之前是进入spark再自增ID），再复现丢数场景后，通过字段查询，找到丢数的字段id，对应到源数据，再对比数据分析

不知道大伙有没有更快捷的的方式定位分析一下


# 2、《Elasticsearch源码解析与优化实战》这本书中,有关6.x的新版副本恢复方法.

书中集群启动流程章节中,副分片recovery模块中有这样描述到:

  旧版副分片恢复都会去从主分片拉取全量的数据.在ES6.x后,优化了这个操作,不拉取全量数据,而是标记每个操作.在正常的写操作中,每次写入成功的操作都分配一个序号,通过对比序号就可以计算出差异范围.
  
  实现方式是: 添加了global checkpoint和local checkpoint,主分片负责维护global checkpoint,代表所有分片都写入这个序号的位置,local checkpoint代表当前分片已写入成功的最新位置,恢复时通过对比两个序列号,计算出缺失的数据范围,然后通过translog重放这部分数据
 
疑问一: 所有分片都写入这个序号的位置,这个所有分片是指主分片还是副分片还是主副分片?

疑问二: 代表当前分片都写入成功的最新位置,这个分片又是指什么分片?

疑问三: 对比两个序列号,计算出缺失的数据范围,那没缺失的数据是如何恢复到副本的?


回复：

Q:所有分片都写入这个序号的位置,这个所有分片是指主分片还是副分片还是主副分片?

A:主分片 && 副分片 都到达了这个序号
 
Q:代表当前分片都写入成功的最新位置,这个分片又是指什么分片?

A:主分片，或者副分片
 
Q:对比两个序列号,计算出缺失的数据范围,那没缺失的数据是如何恢复到副本的?

A：数据没有差异，无需拷贝数据，这个过程就快速完成了

# 3、index的时候那些routing信息存了有什么用？？？

原来一直以为在PUT a/b/c?routing=XXX时，这些XXX信息是不存的。

后来发现它是存到文档里面去的。

想了几天也没有明白存这些信息有什么用？岂不是浪费空间？

“你的问题补充太简单了，一个详细的问题描述能够让大家更快的帮助你，请继续完善问题描述！”？？？

回复：

routing非常有用，可以用来解决很多天生分布式带来的问题，比如算分，比如顺序，比如搜索的正确性。一般场景下很难用到。

https://elasticsearch.cn/question/10654

# 4、elasticsearch多模块是否被覆盖

我的elasticsearch版本是7.7.1。 我的想法是ES在初始化索引时不创建副本，不刷新索引，只有一个主分片。

创建索引后如果遇到logstash-nginx-*的文档就将文档写入logstash-nginx索引里，然后将刷新时间改为120s, 30个主分片，1个副本。

回复：
template里面order的优先级，越大的会覆盖小的

# 5、es7.1es 批量更新字段值报错

回复：
```
POST test/_update_by_query
{
  "script": {
    "lang": "painless",
    "source": "if(ctx._source.age== 29){ctx._source.age= 30}"
  }
}
```
我测试了是可以的。v7.8

# 6、查询量大时，总有少量请求响应时间长，怎样避免呢？
比如一个比较简单的查询，根据用户id查询这个用户的信息，正常情况下都是几ms的响应时间。

当qps到达几千每秒时，总有0.1%不到的比例的查询，响应时间会达到十几或者几十ms，如果是对响应时间要求高的情况，可能就超时了。

服务器资源给的非常充足，每台服务器的cpu使用率连10%都不到，仍然会有这种情况。这样的话即使再加服务器，也没法解决问题。

这种情况可能是什么原因呢，有办法通过调优吗，达到在服务器负载不高的情况下，接近100%的快速响应。

回复：

做到100%的无毛刺是很难的，有时候网络抖动、GC、磁盘等都会出现毛刺的。
 
要解决这个办法，最有效的就是使用补偿查询的方式，当某个请求耗时超过一定比率后，比如超过5ms还未返回，则立即再发出一条一模一样的请求，哪个优先返回用哪个。

回复2：

这种情况一般是查询额外触发了缓存去缓存大量数据，比如 查询5次 会触发缓存， 聚合也会触发缓存，腾讯云Elasticsearch Service 服务做过这方面的内核优化 。

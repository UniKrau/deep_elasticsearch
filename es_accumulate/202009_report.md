# 1、logstash 如何将如下日志中的时间（非data格式）转换为@timestamp

萌新遇到logstash收集日志是无法过滤出非格式化的时间，日志片段如下

[SCRIPT - MUST] 2020.09.23 16:30:31 线程(0)连接(1460)

filter 应该怎么写 才可以将 2020.09.23 16:30:31 提取出来当作@timestamp

```
filter {    
    grok {
        pattern_definitions => { "GROKTIME" => "%{YEAR}.%{MONTHNUM}.%{MONTHDAY} %{HOUR}:%{MINUTE}:%{SECOND}" }
        match => { "message" => "%{GROKTIME:groktime}" }
    }
    date {
        match => [ "groktime", "yyyy.MM.dd HH:mm:ss"]
        remove_field => ["groktime"]
    }
}
```

# 2、es 如何在should 的查询集合中取最大的那个
```
"should": [
     "match_phrase": {"query": "青梅竹马", "boost": 1},
     "match_phrase": {"query": "青梅", "boost": 0.5},
     "match_phrase": {"query": "竹马", "boost": 0.5},
]
```
如果有一个doc 匹配上了“青梅”，“竹马”， “青梅竹马”。我should出来的得分不希望是三个得分相加，而是取最大值。

拜托各位大佬，都来给点建议吧。

回复：

用dis_max，文档是 https://www.elastic.co/guide/en/elasticsearch/reference/7.2/query-dsl-dis-max-query.html



# 3、ES全量备份与增量备份

一、描述：ES权威指南中文版中关于ES的备份有下面这么一句：

“你的第一个快照会是一个数据的完整拷贝，但是所有后续的快照会保留的是已存快照和新数据之间的差异。随着你不时的对数据进行快照，备份也在增量的添加和删除。这意味着后续备份会相当快速，因为它们只传输很小的数据量。”
 
二、问题：
1、如何判断各个快照间的依赖关系？是否可以通过命令查询出来？

2、都是增量，意味着，快照一直都要保留？

3、假设每天或每周对ES做一次快照，后续的快照都是增量的备份，在恢复完整索引的时候，就是需要从第一个快照到后面的所有快照数据都在？

4、后续快照都是增量备份，这个空间只涨不减这个就不大合理了吧。

回复：

以下仅为个人理解，如有其它见解请不吝赐教：

先回答你的问题1. 不同快照之间有相同索引，那么就可能存在依赖，但是并不是所有数据都对旧快照的文件存在依赖关系。没有命令可以查询

2. 如果你不删除旧的快照，文件会一直保留

3. 依据你恢复的快照决定，存在依赖的就会要求相关旧文件

4. 快照需要定期清理的
 
再谈谈快照机制，快照实际就是对lucene文件以及es整合配置的一次备份，备份的主要内容是，lucene core索引文件（实际存储的数据文件），es的配置（存储了如何确定一个索引包含哪些lucene文件的相关配置）。

快照的机制基于lucene的持久化原理，1.只会对数据进行新增，也就是新创建文件，不会修改旧文件；2. 修改数据会执行，将旧数据标为删除，然后新增新数据索引；3. 索引定期进行合并（merge），合并也是生成新的文件，然后删除合并的相关文件。

以上就是说，一个索引，数据一旦变更，那么只会出现新文件生成，旧文件删除。快照就是基于这样的理论去实现的。
 
 
继续你的问题。很大一部分是文件的依赖关系能保持多久，这个很难回答。正常来讲，如果你的索引的旧文件没有发生合并，那么这个依赖文件就会一直存在。如果发生合并，那么依赖关系就不存在了。

总的来说，定期清理快照是非常有必要的。

# 4、

# 1、一个糟糕的设计

https://elasticsearch.cn/question/10827

场景是静态化查询字段+动态关系过滤的问题

由于es无法支持我的关系查询的需要，所以我需要将静态字段查询用es实现（因为字段非常的多，很多是来源于不同的表聚合出来的进=静态字段），动态关系查询用mysql实现，最后将es和mysql的结果集取交集，最后分页。
 
请问有没有什么比较好的实现方案？两个一起使用后运算感觉问题很大?

回复：

这就是糟糕的设计，以后肯定是灾难。

# 2、EQL 不支持哪些操作

PowerShell下如下的运行语句（出于隐私目的，没写出ip和端口）:
 curl.exe -X GET "x.x.x.x:x/_sql" -H 'Content-Type: application/json' -d"SELECT none_pay_course_list FROM user_portrayal where uc_id=4001464" ;
 
运行结果：
{"took":33,"timed_out":false,"_shards":{"total":6,"successful":6,"skipped":0,"failed":0},"hits":{"total":{"value":1,"relation":"eq"},"max_score":0.0,"hits":[{"_index":"user_portrayal","_type":"_doc","_id":"4001464_1","_score":0.0,"_source":{"none_pay_course_list":[{"course":"11_30"},{"course":"11_37"},{"course":"11_23"},{"course":"11_38"}]}}]}}
 
提出问题：
如何改写运行语句，使得能够计算出none_pay_course_list的数组中元素个数。此处目测正确答案为4.（本人试过了split,count,size,length等各种各样的组合，但是还是未得到正确的答案，望得到解答，十分感谢）

直接看官方回复：

https://www.elastic.co/guide/en/elasticsearch/reference/current/eql-syntax.html#eql-syntax-limitations

# 3、ES udpate upsert性能如何优化？

https://elasticsearch.cn/question/10881

ES版本5.6，数据量在3000万左右，数据更新频率比较频繁，总共的更新速度大概是1w/s-5w/s。
最新的数据先进kafka，再由flink消费写入ES。

目前发现在默认的ES配置下，bulk update或者upsert的速度始终上不去，所有节点的cpu使用率才25%左右，速度最高只能到1w/s左右。

如果改成这些数据全部是插入，不做更新操作，那么cpu可以跑满，而且kafka的消费绝对没有积压。

试过增加节点，效果很小，速度看起来有一点点的增加。试过增加分片数，有效果，但仍然不是很明显。
 
请问是什么原因导致这个现象呢，增加分片对写入速度有提升又是为什么呢？

像这种场景，有没有办法直接的提升update/upsert速率，或者间接解决，比如全部用插入的方式写入，查询时同一个id的记录取时间最近的数据。那么查询方式还有删除旧数据这块怎么设计比较好

【精彩回复】

- 1.update是先get再insert然后再delete（标记删除）旧的文档，和insert相比，肯定update耗时多

- 2.由于一次操作完成时长多，线程池数量有限，导致cpu只有25%（猜测...）

- 3.适当增加ES分片，对写入是有一点提高，因为相当于多出来了lucene进程，可以接收的请求多了，付出的代价就是分片多了之后同步数据是需要消耗性能的，然后查询更是会性能降低
- 4.客户端使用层面：可以全部使用insert提高性能，然后定时去delete，定时（低峰期）合并segment，优化数据结构
- 5.集群本身层面：可以控制refresh的频率，translog设置，副本可以先干掉（写完再补回来），线程池参数修改-------这些都是危险操作，评估后再进行实践

在上面基础上补充：
- 1. 使用ES自动的id，不要指定id
- 2. 提高操作系统 filesystem cache
- 3. 关注下 index_buffer_size 这个参数





